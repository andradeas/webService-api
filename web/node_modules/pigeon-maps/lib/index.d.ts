import React, { Component } from 'react';
declare type WAdd = typeof window.addEventListener;
declare type WRem = typeof window.removeEventListener;
declare type Point = [number, number];
interface MoveEvent {
    timestamp: number;
    coords: Point;
}
interface Bounds {
    ne: [number, number];
    sw: [number, number];
}
declare type MinLat = number;
declare type MaxLat = number;
declare type MinLng = number;
declare type MaxLng = number;
declare type MinMaxBounds = [MinLat, MaxLat, MinLng, MaxLng];
interface MapProps {
    center?: Point;
    defaultCenter?: Point;
    zoom?: number;
    defaultZoom?: number;
    width?: number;
    defaultWidth?: number;
    height?: number;
    defaultHeight?: number;
    provider?: (x: number, y: number, z: number, dpr?: number) => string;
    dprs?: number[];
    children?: React.ReactNode;
    animate?: boolean;
    animateMaxScreens?: number;
    minZoom?: number;
    maxZoom?: number;
    metaWheelZoom?: boolean;
    metaWheelZoomWarning?: string;
    twoFingerDrag?: boolean;
    twoFingerDragWarning?: string;
    warningZIndex?: number;
    attribution?: JSX.Element | false;
    attributionPrefix?: JSX.Element | false;
    zoomSnap?: boolean;
    mouseEvents?: boolean;
    touchEvents?: boolean;
    onClick?: ({ event, latLng, pixel }: {
        event: MouseEvent;
        latLng: [number, number];
        pixel: [number, number];
    }) => void;
    onBoundsChanged?: ({ center, zoom, bounds, initial, }: {
        center: [number, number];
        bounds: Bounds;
        zoom: number;
        initial: boolean;
    }) => void;
    onAnimationStart?: () => void;
    onAnimationStop?: () => void;
    limitBounds?: 'center' | 'edge';
    boxClassname?: string;
}
interface TileValues {
    tileMinX: number;
    tileMaxX: number;
    tileMinY: number;
    tileMaxY: number;
    tileCenterX: number;
    tileCenterY: number;
    roundedZoom: number;
    zoomDelta: number;
    scaleWidth: number;
    scaleHeight: number;
    scale: number;
}
declare type WarningType = 'fingers' | 'wheel';
interface MapState {
    zoom: number;
    center: Point;
    width: number;
    height: number;
    zoomDelta: number;
    pixelDelta?: [number, number];
    oldTiles: TileValues[];
    showWarning: boolean;
    warningType?: WarningType;
}
export default class Map extends Component<MapProps, MapState> {
    static defaultProps: {
        animate: boolean;
        metaWheelZoom: boolean;
        metaWheelZoomWarning: string;
        twoFingerDrag: boolean;
        twoFingerDragWarning: string;
        zoomSnap: boolean;
        mouseEvents: boolean;
        touchEvents: boolean;
        warningZIndex: number;
        animateMaxScreens: number;
        minZoom: number;
        maxZoom: number;
        limitBounds: string;
        dprs: any[];
    };
    _containerRef?: HTMLDivElement;
    _mousePosition?: Point;
    _loadTracker?: {
        [key: string]: boolean;
    };
    _dragStart: Point | null;
    _mouseDown: boolean;
    _moveEvents: MoveEvent[];
    _lastClick: number | null;
    _lastTap: number | null;
    _lastWheel: number | null;
    _touchStartPixel: Point[] | null;
    _touchStartMidPoint: Point | null;
    _touchStartDistance: number | null;
    _secondTouchEnd: number | null;
    _warningClearTimeout: number | null;
    _isAnimating: boolean;
    _animationStart: number | null;
    _animationEnd: number | null;
    _zoomStart: number | null;
    _centerTarget: Point | null;
    _zoomTarget: number | null;
    _zoomAround: Point | null;
    _animFrame: number | null;
    _boundsSynced: boolean;
    _minMaxCache: [number, number, number, MinMaxBounds] | null;
    _lastZoom: number;
    _lastCenter: Point;
    _centerStart?: Point;
    constructor(props: MapProps);
    componentDidMount(): void;
    componentWillUnmount(): void;
    updateWidthHeight: () => boolean;
    wa: WAdd;
    wr: WRem;
    bindMouseEvents: () => void;
    bindTouchEvents: () => void;
    unbindMouseEvents: () => void;
    unbindTouchEvents: () => void;
    bindResizeEvent: () => void;
    unbindResizeEvent: () => void;
    bindWheelEvent: () => void;
    unbindWheelEvent: () => void;
    componentDidUpdate(prevProps: MapProps): void;
    setCenterZoomTarget: (center: Point | null, zoom: number, fromProps?: boolean, zoomAround?: Point | null, animationDuration?: number) => void;
    distanceInScreens: (centerTarget: Point, zoomTarget: number, center: Point, zoom: number) => number;
    animationStep: (timestamp: number) => {
        centerStep: Point;
        zoomStep: number;
    };
    animate: (timestamp: number) => void;
    stopAnimating: () => void;
    limitCenterAtZoom: (center?: Point | null, zoom?: number | null) => Point;
    onAnimationStart: () => void;
    onAnimationStop: () => void;
    setCenterZoom: (center?: Point | null, zoom?: number | null, animationEnded?: boolean) => void;
    getBoundsMinMax: (zoom: number) => MinMaxBounds;
    imageLoaded: (key: string) => void;
    coordsInside(pixel: Point): boolean;
    handleTouchStart: (event: TouchEvent) => void;
    handleTouchMove: (event: TouchEvent) => void;
    handleTouchEnd: (event: TouchEvent) => void;
    handleMouseDown: (event: MouseEvent) => void;
    handleMouseMove: (event: MouseEvent) => void;
    handleMouseUp: (event: MouseEvent) => void;
    stopTrackingMoveEvents: () => void;
    trackMoveEvents: (coords: Point) => void;
    throwAfterMoving: (coords: Point, center: Point, zoom: number) => void;
    sendDeltaChange: () => {
        center: Point;
        zoom: number;
    };
    getBounds: (center?: Point, zoom?: number) => {
        ne: Point;
        sw: Point;
    };
    syncToProps: (center?: Point, zoom?: number) => void;
    handleWheel: (event: WheelEvent) => void;
    showWarning: (warningType: WarningType) => void;
    clearWarning: () => void;
    zoomAroundMouse: (zoomDiff: number, event: MouseEvent) => void;
    zoomPlusDelta: () => number;
    pixelToLatLng: (pixel: Point, center?: Point, zoom?: number) => Point;
    latLngToPixel: (latLng: Point, center?: Point, zoom?: number) => Point;
    calculateZoomCenter: (center: Point, coords: Point, oldZoom: number, newZoom: number) => Point;
    setRef: (dom: HTMLDivElement) => void;
    tileValues({ center, zoom, pixelDelta, zoomDelta, width, height, }: {
        center: Point;
        zoom: number;
        pixelDelta?: Point;
        zoomDelta?: number;
        width: number;
        height: number;
    }): TileValues;
    renderTiles(): JSX.Element;
    renderOverlays(): JSX.Element;
    renderAttribution(): JSX.Element | null;
    renderWarning(): JSX.Element | null;
    render(): JSX.Element;
}
export {};
